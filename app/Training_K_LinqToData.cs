// To avoid using the namespace "System.Collection" for all the items of the collections we define:
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

// to create xml trees
using System.Xml.Linq; 


// namespaces from my own classes;
 using StudentStuff;

// Anounymous Types Training. 

namespace TrainingStuffK
{

    public class ProgramK
    {

        public static void MainProcess ()
        {
            Console.WriteLine(" !!I AM THE PROGRAM K - Training of LINQ To Data!! ");   
                       
            // SUMMARY:
            // - We use LINQ for data when the data is defined in an external source (for example, a BD). 
            // Its methods are defined in the IQueryable interface, which have to implement all the sources 
            // that support this functionality.

            // - A query in LINQ for data is interpreted by the provider of the data source and transformed 
            // to the source language. Once the data is obtained, the reverse process occurs, and the data 
            // obtained at the source becomes CLR objects. This second process is called materialization.

            // - There is a set of functions known as canonical functions that offer support to operations whose 
            // implementation varies depending on the provider. This type of functions allow us, for example, to
            // obtain the current date, concatenate chains or obtain their length.

            // - When we make queries in LINQ for data we must be careful with the hidden complexity that the queries 
            // generated by the provider in the source language can introduce. For example, to make queries 
            // about relational databases, the provider may be using join operations to cross the data from several tables.


            /*
            The data is defined in an external source (for example, a BD). 
            The LINQ methods for the objects are defined in the IEnumerable interface. 
            In contrast, LINQ methods for data are defined in the IQueryable interface, which 
            must implement all source data sets that are compatible with this functionality.

            Unlike IEnumerable, which defines the implementation of LINQ methods for objects, 
            IQueryable only defines the contract of the methods, but the implementation is the realization of each provider. 
            When we define a query on IQueryable or IQueryable<T>, we are actually defining an expression tree 
            that is then evaluated according to the implementation that each provider makes of the interface ( Excel, EQL Data base, XML file etc...).
            For example, LINQ to SQL and LINQ to Entities each have their own implementation of LINQ methods, 
            but for our queries it is transparent to be using one or the other.

            In this chapter we are going to learn about LINQ to Data. We use LINQ for data when data will be defined in an external source (for example, a DB (Oracle, MongoDB, etc...)). 
            Defined methods in the IQueryable interface must be implemented all the origins supported by this functionality. 

            A query on LINQ for data is interpreted as follows: 
            - The data provider of the data origin transforms the query to the origin language.
            - Executes the query to obtain data. 
            - The obtained data in origin is converted into objects of the CLR 
                (Common Language Runtime - CLR is technology for hosting of the Microsoft .NET common language runtime engine within SQL Server. 
                The SQLCLR allows managed code to be hosted by, and run in, the Microsoft SQL Server environment). 
                This second process is called materialization. 

            In LINQ queries for data we have to be careful with the hidden complexity that the queries can introduce 
            generated by the provider in the origin language.

            Queries with LINQ for data are carried out in the same way as LINQ queries for objects, 
            but some of the LINQ methods for objects are not available when using LINQ for data. 
            For example, you can use sorting methods, such as OrderBy( ) and ThenBy( ), but you can not use the overhead that receives an IComparer.
            
            LINQ for entities never directly returns the records generated by the execution of the query on the source. Instead, it materializes them into CLR types.
            The MATERIALIZATION is the process by which the results of the query to the client are returned in the form of CLR types.

            These types can be anonymous, or defined types, or a list of the previous ones. In case it is not possible to materialize the result of 
            the query to a type or collection of types of the CLR, an exception occurs.
            To perform the materialization of the queries, auxiliary queries are executed that introduce a small extra cost in the operation.
            If we are using Visual Studio, we can use IntelliTrace to see the translation made by the LINQ query provider. 

            Just as in LINQ for objects, if we do not need to map all the values of the records of the query, we can create an anonymous object and return only 
            the properties that are of interest, reducing the time necessary to obtain the data at source and map the result to a CLR object.
            
            
            // Canonical functions
            As we discussed at the beginning of this chapter, the implementation of LINQ methods in LINQ for data is done by each provider, 
            depending on the characteristics of the system that is the origin of the data. For example, when we use the Entity Framework with SQL Server, 
            LINQ queries are translated into an expression tree and then the provider analyzes the resulting expression, 
            translates it into an SQL query and runs it over SQL Server to obtain the data.
            
            Sometimes, our queries can include calls to methods to obtain values ​​(for example, the current date and time) or format the obtained
            data (for example, eliminate blank spaces at the ends of a chain). This is a problem because, as each provider translates and executes the query
            based on the source, the name of the functions provided by the source to perform these operations may be different in each case, 
            and the usual C # functions may not be available.
            
            In addition, the error that occurs is not in compilation, but in execution, when the query is executed and the provider has to translate
            the resulting expression into the corresponding language of the data source.
            
            For example, that the following query is not valid in LINQ for entities:
            var res = stock.Where (s => s.ExpirationDays.AddDays (7)> ​​DateTime.Now ( ) )

            To alleviate this problem, canonical functions were created, which are methods defined at the interface level and whose implementation depends on the provider.
            For example, in this case, instead of using the AddDays( ) method of DateTime, which is not available, we can use the AddDays( ) definition of DbFunctions:
                var res = stock.Where (s => DbFunctions.AddDays (s.ExpirationDays, 7)> DateTime.Now)

            The DBFunctions class is defined in System.Data.Entity.
            The realization of all the elements of the query should never be forced (for example, with ToList ( )) in order to use the methods not available in LINQ for data.
            
            *Resolution of relationships between entities*
            When converting the object-oriented model to a relational model, we may need to create intermediate tables 
            to represent complex relations between the elements. This means that, internally, 
            we can be making more complex queries than we think.

            Example: students enrolled in various courses
            We want to obtain a list of students who have signed up for more than one course and, for this, 
            we will use LINQ for data with the Entity Framework.

            We have the following object model:
                - A student keeps a list of courses to which he is enrolled.
                - A course keeps a list of students who are targeted to it.
            
            
            As we have seen so far, when we work with LINQ for data, the queries that each provider generates 
            from the expression tree depend on the structure of the data at the origin. In relational databases, 
            this implies that our queries usually include the intermediate tables that relate our data.

            For this reason, it may be that a LINQ query in LINQ for data performs join operations that we have 
            not explicitly indicated in our LINQ statement. This is called an implicit join. The danger of implicit
            joins is that they add extra complexity to our queries that we may not be taking into account if 
            we only analyze the complexity of the LINQ query.


            *Combination of data (join) in LINQ for Data*
            As we have seen so far, when we work with LINQ for data, the queries that each provider generates from the expression tree 
            depend on the structure of the data at the origin. In relational databases, this implies that our queries usually include 
            the intermediate tables that relate our data.
            
            For this reason, it may be that a LINQ query in LINQ for data performs join operations that we have not explicitly indicated 
            in our LINQ statement. This is called an implicit join. The danger of implicit joins is that they add extra complexity to our queries 
            that we may not be taking into account if we only analyze the complexity of the LINQ query.

            In addition to implicit combinations, we can also perform them explicitly using the Join( ) and GroupJoin( ) methods. When the origin 
            of our data is a relational database, the Join () method usually has a direct conversion with the inner join operation supported by
            the database system we are using.
            In the case of GroupJoin( ) the usual thing is that the corresponding operation in the database is a left outer join, 
            but it can derive in several operations left join, inner join, group by and order by, depending on the provider that we are using. 
            So, again, we must bear in mind that the operation executed below in the provider may have a greater complexity than we expect.

            *Denormalized models*

            Performing join operations adds complexity to our queries, which translates into a longer execution time to obtain a result and, 
            therefore, lower performance. Therefore, sometimes we are more interested in the model of our database that reflects the 
            data that we usually consult, and not exactly the business model. In this way, our queries can always be made without 
            the need to obtain and combine data from several tables.

            These types of models are known as denormalized models. With the denormalización we get that these pieces of knowledge, 
            which are usually distributed among different objects of the business model, are grouped in one place. The cost of 
            the combination does not disappear, but it is transferred to the moment in which the data persists. 
            However, saving the data is something we only do once, so you can compensate us by transferring this cost to that 
            operation in exchange for saving it in the consultations, when inquiries about the data are frequent.
            
            Example: show course information.
            
            Using the data model of students and courses that we have seen in previous examples, we want to create an interface that offers us information about the available courses. In this interface we want to show the following information:

                - Name of the course (course ID).
                - Description.
                - Start date.
                - Hours of duration.
                - Number of students enrolled.

            This means that we are going to consult frequently the number of students of each course, 
            therefore, it can interest us to denormalize the model of the courses and to take them to him the information of the number of students subscribed, instead of having to calculate it each time that the interface is showed.
            

            *Linq to XML*
            XML has been adopted as a way to format data in many contexts (XML on the Web, databases, ...) 

            LINQ to XML provides the in-memory document modification of the Document Object Model (DOM), 

            ( DOM --> https://es.wikipedia.org/wiki/Document_Object_Model )

            and supports LINQ query expressions. These query expressions provide similar functionality than XPath. 
            You can query and modify the document, and after you modify it, you can save it to a file or serialize 
            it and send it over the Internet. 

            Differences between "LINQ to XML"  and  "DOM":
            - Provides a new object model that is lighter weight and easier to work with.
            - Takes advantage of language features in C #.
            - Enables you to write queries on the memory XML document to retrieve collections of elements and attributes.
            - Allow the developers to use query results as parameters to XElement and XAttribute object constructor to create XML trees.
            - Enables to easily transform XML trees from one shape to another.
            - Allow you to load, serialize, create, validate and manipulate XML.


            --> Creating an XML Tree
            INQ to XML provides a powerful way to create XML elements in a single statement called functional construction.

            An example of this is:

            XElement contacts =  
                new XElement("Elements",  
                    new XElement("Element",  
                        new XElement("Name", "Alexander"),  
                        new XElement("Surname", "Philips"),  
                        new XElement("phone", "425-555-0145",  
                            new XAttribute("Type", "Work")),  
                        new XElement("Address",  
                            new XElement("Street", "Main St"),   
                            new XElement("City", "London")  
                        ),
                        new XElement("Age", "35")  
                    )  
                );
              Console.WriteLine(contacts);


            Passing another XElement object, it becomes a child element.
            Passing an XAttribute object, becomes an attribute of the element.
            Passing another type of object, becomes the text content of the element.


            Executing the example above it will show the next structure:

            <Elements>
                <Element>
                    <Name>Alexander</Name>
                    <Surname>Philips</Surname>
                    <phone Type="Work">425-555-0145</phone>
                    <Address>
                        <Street>Main St</Street>
                        <City>London</City>
                    </Address>
                    <Age>35</Age>
                </Element>
            </Elements>

            We can create an xml tree from a string, a file, a TextReader and a XmlReader.
            */

        }    

        public static void StringToXMLTree()
        {
            // HOW TO PARSE A STRING TO CREATE AN XML TREE

            //The following code, apart from creating an XML tree, controls the errors thrown by the parse of invalid XML:


            try {  
                string theXml = @"<root>
                                        <var>
                                            <tag>value1</tag>
                                        </var>
                                        <var>
                                            <tag>value2</tag>
                                        </var>
                                        <var>
                                            <tag>value3</tag>
                                        </var>
                                    </root>";

                // We can parse it in the next way:
                XElement data = XElement.Parse(theXml);
                Console.WriteLine(data);

                // Creating a file that contains the data of the XML 
                data.Save("Example1.xml");
            }
            catch (System.Xml.XmlException e)
            {
                Console.WriteLine(e.Message);
            }
        }
        
        public static void LoadXMLfromFile()
        {
            // HOW TO PARSE A STRING TO CREATE AN XML TREE
            XElement xml_test = XElement.Load(@"Example1.xml");

            // We display it trough  to the console
            Console.WriteLine(xml_test);

        }

        public static void LoadXMLfromTextReader()
        {
            // LOADING XML FROM A TEXTREADER
            TextReader reader = new StringReader("<root><var><tag>value1</tag></var><var><tag>value2</tag></var></root>");  
            XElement xml= XElement.Load(reader); 

            Console.WriteLine(xml);  

        }

        // *Retrieving elements and attributes*
        //The next methods return IEnumerable<T> of XElement collections from an XML file
        public static void Descendants_XML()
        {

            XElement dataXML = XElement.Load("Example1.xml");  

            Console.WriteLine("\nAll the descendant elements in the XML file are printed : "); 
            // All elements that are children of something else --> root is father ( so not ); so "tag" and "var"

            IEnumerable<XElement> elements = dataXML.Descendants();
                foreach (var c in elements)
                    Console.WriteLine(c.Name);


            // just descendants
            Console.WriteLine("\nJust the descendent field var : ");
            IEnumerable<XElement> elements2 = dataXML.Descendants("var");
                foreach (var c in elements2)
                    Console.WriteLine(c.Name);
        }

        public static void Ancestors_XML()
        {

            XElement dataXML = XElement.Load("Example1.xml");  
        
            // Returns a collection of the ancestor elements of this node.
            IEnumerable<XElement> elements = dataXML.Descendants("tag"); // we get all the "tags" which are the ones that are just children
        
            // All elements that are parent of something else --> "root" and "var" are parents 
            foreach (var c in elements.Ancestors())
                    Console.WriteLine(c.Name);
        }

        public static void Elements_XML()
        {

            XElement dataXML = XElement.Load("Example1.xml");  
        
            // Returns a collection of the child elements of this element or document, in document order.
            // the upper parent will not be considered
            IEnumerable<XElement> elements = dataXML.Elements(); // in blackets "()" we will introduce the parent of the elements. 
            foreach (XElement el in elements)  
                Console.WriteLine(el); 
        }
        public static void Retrieve_Value_Element()
        {
            XElement dataXML = XElement.Load("Example1.xml");  

            // we get just the elements under de element "Var" --> so just a lineal collection of "roots" elements. 
            var elements = dataXML.Descendants("var");
            foreach (var c in elements){
                // we access the value of the field "tag"
                Console.WriteLine(c.Element("tag").Value); // Option1
                Console.WriteLine((string)c.Element("tag")); // Option2
                // Using both we access to the value of that field 
            }      
        }

        public static void StringToXMLTreeWithAttributs()
        {
            // HOW TO PARSE A STRING TO CREATE AN XML TREE

            //The following code, apart from creating an XML tree, controls the errors thrown by the parse of invalid XML:


            try {  
                string theXml = @"<root>
                                        <var atributo = ""attr1"" atributoB = ""attr233"">
                                            <tag>value1</tag>
                                        </var>
                                        <var atributo = ""attr2"">
                                            <tag>value2</tag>
                                        </var>
                                        <var atributo = ""attr3"">
                                            <tag>value3</tag>
                                        </var>
                                    </root>";

                // We can parse it in the next way:
                XElement data = XElement.Parse(theXml);
                Console.WriteLine(data);

                // Creating a file that contains the data of the XML 
                data.Save("Example3.xml");
            }
            catch (System.Xml.XmlException e)
            {
                Console.WriteLine(e.Message);
            }
        }

        // **RETRIEVING ATTRIBUTES**
        public static void Retrieve_Atributes()
        {
            XElement dataXML = XElement.Load("Example2.xml");  

            // we get just the elements under de element "Var" --> so just a lineal collection of "roots" elements. 
            IEnumerable<XElement> elements = dataXML.Elements("var");
            IEnumerable<XAttribute> attributes =  elements.Attributes();

            foreach (XAttribute a in attributes){
                // we access the value of the field "tag"
                Console.WriteLine(a); // Option1

            }      
        }

        public static void Retrieve_SingleAtribute()
        {
            XElement dataXML = XElement.Load("Example3.xml");  

            // we get just the elements under de element "Var" --> so just a lineal collection of "roots" elements. 
            IEnumerable<XElement> elements = dataXML.Elements("var");

            // we get the attribute from field "var" that is called "atributoB"
            foreach (XElement e in elements){            
                Console.WriteLine(e.Attribute("atributoB"));  // Option1 -> name attribute plus value
                Console.WriteLine((string)e.Attribute("atributoB")); // Option2 --> just the value of the attribute

            }      
        }

        public static void AddingElementsToXMLTree()
        {
            string theXml = @"<root>
                                <var atributo = ""attr1"">
                                    <tag>value1</tag>
                                </var>
                                <var atributo = ""attr2"">
                                    <tag>value2</tag>
                                </var>
                            </root>";
            XElement dataXML = XElement.Parse(theXml);

            // we define the new element:
            XElement newElement = 
                            new XElement("var",
                                new XElement("tag", "newValue")
                                    );
            dataXML.Add(newElement);
            dataXML.Save("Example4.xml");
     
        }


        public static void RemoveElementOfXMLTree()
        {
            string theXml = @"<root>
                                    <element1 attribute = ""attr1"">
                                        <tag1>value1</tag1>
                                    </element1>
                                    <element2 attribute = ""attr2"">
                                        <tag2>value2</tag2>
                                    </element2>
                                </root>";
            XElement dataXML = XElement.Parse(theXml);

            // we define the new element:
            dataXML.Element("element1").Elements().Remove();  // remove the elements inside element 1 --> tag1
            dataXML.Element("element2").RemoveAttributes();  // remove the attributes inisde element 2 -> attribute = ""attr2""

            dataXML.Save("Example5.xml");
     
        }

        public static void RemoveNodesOfXMLTree()
        {
            string theXml = @"<root>
                                    <element1 attribute = ""attr1"">
                                        <tag1>value1</tag1>
                                    </element1>
                                    <element2 attribute = ""attr2"">
                                        <tag2>value2</tag2>
                                    </element2>
                                </root>";
            XElement dataXML = XElement.Parse(theXml);


            /*
            According to the XML DOM, everything in an XML document is a node:

            The entire document is a document node
            Every XML element is an element node
            The text in the XML elements are text nodes
            Every attribute is an attribute node
            Comments are comment nodes

            <?xml version="1.0" encoding="UTF-8"?>
            <bookstore>
                <book category="cooking">
                    <title lang="en">Everyday Italian</title>
                    <author>Giada De Laurentiis</author>
                    <year>2005</year>
                    <price>30.00</price>
                </book>
                <book category="children">
                    <title lang="en">Harry Potter</title>
                    <author>J K. Rowling</author>
                    <year>2005</year>
                    <price>29.99</price>
                </book>
            </bookstore>

            The root node in the XML above is named <bookstore>.
            All other nodes in the document are contained within <bookstore>.
            The root node <bookstore> holds 2 <book> nodes.
            The first <book> node holds the child nodes: <title>, <author>, <year>, and <price>.
            The child nodes contain one text node each, "Everyday Italian", "Giada De Laurentiis", "2005", and "30.00".

            */

            // we define the new element:
            dataXML.Element("element2").RemoveNodes();// remove all the nodes inside element 2 ..> its childs nodes ( not the attributes )
          
            Console.WriteLine(dataXML);

     
        }



    }
}

